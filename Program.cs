using Asp.Versioning;
using Asp.Versioning.Builder;
using System.Text.Json;
using VulnerablityFinder.Models;
using VulnerablityFinder.Providers;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddApiVersioning();
builder.Services.AddTransient<IVulnerabilityProvider, GithubProvider>();

var app = builder.Build();

app.UseHttpsRedirection();

ApiVersionSet apiVersionSet = app.NewApiVersionSet().HasApiVersion(new ApiVersion(1)).Build();

app.MapPost("/api/v{version:apiVersion}/scan", Scan).WithApiVersionSet(apiVersionSet).MapToApiVersion(1);

app.Run();

static async Task<IResult> Scan(HttpRequest request, IVulnerabilityProvider provider)
{
    var ecosystem = request.Form["ecosystem"].ToString();
    var fileContent = request.Form["fileContent"].ToString();
    if (string.IsNullOrEmpty(ecosystem) || string.IsNullOrEmpty(fileContent))
    {
        return TypedResults.BadRequest();
    }

    var jsonString = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(fileContent));
    IEnumerable<Package> packagesToTest;
    try
    {
        var packageJson = JsonSerializer.Deserialize<PackageJson>(jsonString, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
        packagesToTest = packageJson.Dependencies.Select(kv => new Package(kv.Key, kv.Value));
        if (packagesToTest is null || !packagesToTest.Any()) return TypedResults.BadRequest();
    }
    catch
    {
        return TypedResults.BadRequest();
    }

    return TypedResults.Ok(await provider.TestPackages(ecosystem, packagesToTest));
}
