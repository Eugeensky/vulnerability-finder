using GraphQL.Client.Http;
using GraphQL.Client.Serializer.Newtonsoft;
using System.Net.Http.Headers;
using VulnerablityFinder.Models;

namespace VulnerablityFinder.Providers
{
    public class GithubVulnerabilityProvider : IVulnerabilityProvider
    {
        public async Task<ScanResult?> ScanPackages(string ecosystem, IEnumerable<Package> packages)
        {
            var token = Environment.GetEnvironmentVariable("GITHUB-ACCESS-TOKEN");
            if (string.IsNullOrEmpty(token)) return null;

            var graphQLClient = new GraphQLHttpClient("https://api.github.com/graphql", new NewtonsoftJsonSerializer());
            graphQLClient.HttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
            
            var query = $@"
query securityVulnerabilities($package: String) {{
  securityVulnerabilities(ecosystem: {ecosystem.ToUpperInvariant()}, first: 100, package: $package) {{
    nodes {{
      severity
      advisory {{
        summary
      }}
      package {{
        name
        ecosystem
      }}
      vulnerableVersionRange
      firstPatchedVersion {{
        identifier
      }}
    }}
  }}
}}";

            var vulnerablePackages = new List<VulnerablePackage>();
            foreach(var package in packages)
            {
                if (package is null) continue;
                var request = new GraphQLHttpRequest() { Query = query, Variables = new { package = package.Name } };
                var response = await graphQLClient.SendQueryAsync<VulnerablePackagesReport>(request);

                if(response.Errors is null && response.Data is not null)
                {
                    foreach(var node in response.Data.SecurityVulnerabilities.Nodes)
                    {
                        // avoid beta versions like 5.0.0-beta when comparing versions
                        var firstPatchedVersion = node.FirstPatchedVersion.Identifier.Split('-')[0];
                        var currentVersion = package.Version.Split('-')[0];
                        if (firstPatchedVersion is not null && currentVersion is not null && new Version(firstPatchedVersion).CompareTo(new Version(currentVersion)) > 0)
                        {
                            vulnerablePackages.Add(new VulnerablePackage(package.Name, package.Version, node.Advisory.Summary, node.Severity, node.FirstPatchedVersion.Identifier));
                        }
                    }
                }
            }
           
            return new ScanResult(vulnerablePackages);
        }
    }
}
